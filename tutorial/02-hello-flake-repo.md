# The hello-flake repo

Let's clone the repository and see how the flake is defined.

~~~
$ cd ~/tutorial-practice
$ git clone https://codeberg.org/mhwombat/hello-flake
$ cd hello-flake
$ ls
~~~

This is a simple repo with just a few files.
Like most git repos, it includes
`LICENSE`, which contains the software license,
and `README.md` which provides information about the repo.

The `hello-flake` file is the command we were executing earlier.
This particular executable is just a shell script, so we can view it.
It's an extremly simple script with just two lines.

~~~
$ cat hello-flake
~~~

Now that we have a copy of the repo, we can execute this script directly.

~~~
$ ./hello-flake
~~~

Not terribly exciting, I know.
But starting with such a simple package makes it easier to focus on the flake
system without getting bogged down in the details.
We'll make this script a little more interesting later.

Let's look at another file.
The file that defines how to package a flake is always called `flake.nix`.

~~~
$ cat flake.nix
~~~

If this is your first time seeing a flake definition,
it probably looks intimidating.
Flakes are written in a functional language called Nix[^nix-language].
Yes, "Nix" is the name of both the package manager and the language it uses.
We'll look at this in more detail shortly.
For now, I'd like to focus on the inputs section.

[^nix-language]: For an introduction to the Nix language, see [Nix language basics](https://nixos.org/guides/nix-language.html).

~~~
inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };
~~~

There are just two entries, one for `nixpkgs` and one for `flake-utils`.
The first one, `nixpkgs` refers to the collection of standard software packages that can be installed with the Nix package manager.
The second,  `flake-utils`, is a collection of utilities that simplify writing flakes.
The important thing to note is that the `hello-flake` package *depends* on `nixpkgs` and `flake-utils`.

Finally, let's look at `flake.lock`, or rather, just part of it.

~~~
$ head -n 40 flake.lock
~~~

If `flake.nix` seemed intimidating, then this file looks like an invocation for Cthulhu.
The good news is that this file is automatically generated; you never need to write it.
It contains information about all of the dependencies for the flake,
including where they came from, the exact version/revision, and hash.
This lockfile *uniquely* specifies all flake dependencies,
(e.g., version number, branch, revision, hash),
so that *anyone, anywhere, any time,
can re-create the exact same environment that the original developer used.*

No more complaints of "but it works on my machine!".
That is the benefit of using flakes.

